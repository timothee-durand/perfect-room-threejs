<!DOCTYPE HTML>
<html lang="fr">
<head>
    <title>Perfect Room</title>
    <meta charset="UTF-8">
    <link href="images/icon.png" rel="icon" type="image/png"/>
    <style>
        body {
            margin: 0px;
            padding: 0px;
            background-color: #777777;
        }

        #canvas {
            display: block;
            position: absolute;
            left: 10px;
            top: 10px;
            right: 434px;
            bottom: 10px;
            background-color: #000000;
        }

        #info {
            display: block;
            position: absolute;
            width: 400px;
            top: 10px;
            right: 10px;
            bottom: 10px;
            background-color: #EEEEEE;
            border: 2px solid white;
            padding: 5px;
            font-size: 14pt;
            font-family: times new roman;
            font-weight: bold;
            font-style: italic;
            color: black;
        }

        input {
            background-color: #FFFFFF;
            border: none;
            width: 260px;
            color: black;
            font-size: 14pt;
            font-family: times new roman;
            font-weight: bold;
        }

        #divTexture {
            display: block;
            position: absolute;
            width: 256px;
            height: 256px;
            bottom: 5px;
            left: 5px;
            background-color: black;
            border: 1px solid white;
            padding: 0px;
            color: white;
        }

        #canvasTexture {
            width: 256px;
            height: 256px;
            background: white;
        }
    </style>
</head>
<body>

<div id="canvas"></div>
<div id="info">
    <table>
        <tr>
            <td>Click position:</td>
            <td><input class="info" id="positions" type="text" value="(0;0)"/></td>
        </tr>
        <tr>
            <td>Clicked object:</td>
            <td><input class="info" id="obj_name" type="text" value="vide"/></td>
        </tr>
        <tr>
            <td>Action:</td>
            <td><input class="info" id="action" type="text" value="0"/></td>
        </tr>
        <ul id="objects">

        </ul>
    </table>
    <div id="divTexture">
        <canvas height="256" id="canvasTexture" width="256"/>
    </div>
</div>

<script type="module">
    import * as THREE from './three.js-dev/build/three.module.js';
    import {OrbitControls} from './three.js-dev/examples/jsm/controls/OrbitControls.js';
    import {ColladaLoader} from './three.js-dev/examples/jsm/loaders/ColladaLoader.js';

    var clickInfo = [];
    //tableau qui contient la liste des objets clickables
    let animations = [];
    var container = document.getElementById("canvas");

    // variables utilisées par les deux fonctions
    var renderer, camera, scene, controls;
    var clock = new THREE.Clock();
    var SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_LEFT, SCREEN_TOP;
    const raycaster = new THREE.Raycaster();
    var currentCode = "", goodCode = "1 5 9 0 # ", codeBon = false;

    let canvaTexture, canvaContext, textureEcran, canvaMaterial;

    function onClickEvent(event) {
        clickInfo.userHasClicked = true;
        clickInfo.mouse = new THREE.Vector2();
        clickInfo.mouse.x = ((event.clientX - SCREEN_LEFT) / SCREEN_WIDTH) * 2 - 1;
        clickInfo.mouse.y = -((event.clientY - SCREEN_TOP) / SCREEN_HEIGHT) * 2 + 1;
    }

    function onWindowResize() {
        let w = container.offsetWidth;
        let h = container.offsetHeight;
        SCREEN_WIDTH = container.scrollWidth;
        SCREEN_HEIGHT = container.scrollHeight;
        SCREEN_LEFT = container.offsetLeft - container.scrollLeft + container.clientLeft;
        SCREEN_TOP = container.offsetTop - container.scrollTop + container.clientTop;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
    }

    function start() {
// initialisation du moteur de rendu
        renderer = new THREE.WebGLRenderer();
// création d'un canvas dans un div
        renderer.setClearColor(0x222222, 1);
        window.addEventListener('resize', onWindowResize, false);

        container.appendChild(renderer.domElement);
        container.addEventListener('click', onClickEvent, false);

        let w = container.offsetWidth;
        let h = container.offsetHeight;
        SCREEN_WIDTH = container.scrollWidth;
        SCREEN_HEIGHT = container.scrollHeight;
        SCREEN_LEFT = container.offsetLeft - container.scrollLeft + container.clientLeft;
        SCREEN_TOP = container.offsetTop - container.scrollTop + container.clientTop;
        renderer.setSize(w, h);

// création d'une caméra perspective(angle d'ouverture, rapport largeur/hauteur, near, far)
        camera = new THREE.PerspectiveCamera(30, w / h, 1, 60000);
        camera.position.set(50 / 2.54, 170 / 2.54, 600 / 2.54);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 160 / 2.54, 0);
        // controls.minAzimuthAngle = THREE.Math.degToRad(-70.0);
        // controls.maxAzimuthAngle = THREE.Math.degToRad(80.0);
        //controls.minPolarAngle = THREE.Math.degToRad(50.0);
       // // controls.maxPolarAngle = THREE.Math.degToRad(140.0);
       //  controls.minDistance = 100 / 2.54;
       //  controls.maxDistance = 1000 / 2.54;
       //  controls.enablePan = false;
        controls.update();

// création de la scène
        scene = new THREE.Scene();
        scene.add(camera);

        clock.start();
        var loader = new ColladaLoader();
        loader.load('./models/room_durand_gaultier_1.3.1.dae', onLoaded, onProgress, onError);

// sources de lumière (une ambiante et une ponctuelle placée en [-10;100;200])
        var ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);

        canvaTexture = document.getElementById("canvasTexture");
        canvaContext = canvaTexture.getContext("2d");
        textureEcran = new Image();
        textureEcran.src = "./models/textures/clavier_coffre.png";

        console.log(canvaTexture, canvaContext, textureEcran)
    }

    function animate() {
// rendu de la scène
        controls.update();
        renderer.render(scene, camera);

        // détection du picking
        if (clickInfo.userHasClicked) {
            clickInfo.userHasClicked = false;
            raycaster.setFromCamera(clickInfo.mouse, camera);
            let intersections = raycaster.intersectObjects(scene.children, true);
            let obj = null;

            document.getElementById("positions").value = `(${clickInfo.mouse.x.toFixed(2)},${clickInfo.mouse.y.toFixed(2)})`;
            if (intersections.length > 0) {
                obj = intersections[0].object;
                while (obj != null && obj.name === "") {
                    obj = obj.parent;
                }
                document.getElementById("obj_name").value = `${obj.name} uv=(${intersections[0].uv.x.toFixed(2)},${intersections[0].uv.y.toFixed(2)})`;
            }

            if (obj) {
                animations.forEach(function (anim) {
                    if (anim.name === obj.name) {
                        anim.onClick(intersections[0]);
                    }
                })
            }
        }

        let dt = clock.getDelta();

        animations.forEach(function (anim) {
            //si il y a une animation à lancer la met à jour
            anim.updateAnimation(dt);
        })


// lancement du frame suivant
        requestAnimationFrame(animate);
    }

    let roundOff = (num, places) => {
        const x = Math.pow(10, places);
        return Math.round(num * x) / x;
    }

    function onLoaded(collada) {
        let object = collada.scene;

        scene.add(object);
        object.scale.set(0.4, 0.4, 0.4);
        let dt = clock.getElapsedTime();
        document.getElementById('action').value = "Load completed after " + dt.toFixed(2) + " s.";

        let light1 = object.getObjectByName('spot1');
        light1.penumbra = 43.0 / 60.0;
        light1.distance = 170.0 / 2.54;
        light1.target = object.getObjectByName('spot1.Target');
        light1.visible = false; //éteint la lumière

        let button = object.getObjectByName('button1');
        button.rotation.x = THREE.Math.degToRad(10.0);
        let myMat = button.material.clone();
        button.material = myMat;
        myMat.color = new THREE.Color(1.0, 0.0, 0.0);
        myMat.emissive = new THREE.Color(1.0, 0.0, 0.0);
        //ajout d'un paramètre pour savoir son état
        button.state = false;

        let button2 = object.getObjectByName('button2');
        button.rotation.x = THREE.Math.degToRad(-10.0);
        let mat2 = button2.material.clone();
        mat2.color = new THREE.Color(0.0, 1.0, 0.0);
        mat2.emissive = new THREE.Color(0.0, 1.0, 0.0);
        button2.state = true;

        button.onClick = function (intersection) {
            this.state = !this.state;
            light1.visible = this.state;
            if (this.state) {
                this.material = myMat;
                this.rotation.x = THREE.Math.degToRad(-10.0);
            } else {
                this.material = mat2;
                this.rotation.x = THREE.Math.degToRad(10.0);
            }
        };
        button.updateAnimation = (dt) => {
        };
        animations.push(button);

        console.log("sjgkljdfgnlkdfjgblkdfjg",object.getObjectByName("Clavier"))

        button2.onClick = function (intersection) {
            let spot2 = object.getObjectByName("spot2");
            this.state = !this.state;
            spot2.visible = this.state;

            if (this.state) {
                this.material = myMat;
                this.rotation.x = THREE.Math.degToRad(-10.0);
            } else {
                this.material = mat2;
                this.rotation.x = THREE.Math.degToRad(10.0);
            }
        };
        button2.updateAnimation = (dt) => {
        };
        animations.push(button2);

        let cadre = object.getObjectByName("cadre");
        animations.push(cadre);
        cadre.animationStatus = 0;
        cadre.amin = (-Math.PI) / 2;
        cadre.amax = 0;
        cadre.duration = 2;
        cadre.onClick = function (intersection) {
            switch (this.animationStatus) {
                case 0:
                    if (Math.pow(intersection.uv.x - 0.93, 2) + Math.pow(intersection.uv.y - 0.6, 2)
                        <= Math.pow(0.03, 2)
                    ) this.animationStatus = 1;
                    break;
                case 2 :
                    this.animationStatus = 3;
                    break;
            }

        }
        cadre.updateAnimation = function (dt) {
            let angle = dt * (this.amax - this.amin) / this.duration;
            switch (this.animationStatus) {
                case 1:
                    this.rotation.z -= angle;
                    if (this.rotation.z < this.amin) {
                        this.rotation.z = this.amin;
                        this.animationStatus = 2
                    }
                    break;
                case 3:
                    this.rotation.z += angle;
                    if (this.rotation.z > this.amax) {
                        this.rotation.z = this.amax;
                        this.animationStatus = 0
                    }
                    break;
            }
        };

        let porte = object.getObjectByName("porte");
        porte.animationStatus = 0;
        porte.amax = -Math.PI / 2;
        porte.amin = 0;
        porte.duration = 2;
        porte.waitTime = 5;
        porte.onClick = function (intersection) {
            drawCanvas(intersection.uv.x, intersection.uv.y)
        }
        porte.updateAnimation = function (dt) {
            let angle = dt * (this.amax - this.amin) / this.duration;
            switch (this.animationStatus) {
                case 1:
                    this.rotation.z += angle;
                    if (this.rotation.z < this.amax) {
                        this.rotation.z = this.amax;
                        this.animationStatus = 2
                        this.t1 = this.waitTime;
                    }
                    break;
                case 2:
                    this.t1 -= dt;
                    if (this.t1 <= 0) {
                        this.animationStatus = 3;
                    }
                    break;
                case 3:
                    this.rotation.z -= angle;
                    if (this.rotation.z > this.amin) {
                        this.rotation.z = this.amin;
                        this.animationStatus = 0
                        verrou.animationStatus = 3;
                    }
                    break;
            }
        }
        animations.push(porte)


        let verrou = object.getObjectByName("verrou");
        verrou.animationStatus = 0;
        verrou.xmin = 9.9 * 25.4;
        verrou.xmax = 10.8 * 25.4;
        verrou.duration = 2;
        verrou.onClick = function () {
        }

        verrou.updateAnimation = function (dt) {
            let dist = dt * (this.xmax - this.xmin) / this.duration;
            switch (this.animationStatus) {
                case 1:
                    this.position.x -= dist;
                    if (this.position.x < this.xmin) {
                        this.position.x = this.xmin;
                        this.animationStatus = 2;
                        porte.animationStatus = 1;
                    }
                    break;
                case 3:
                    this.position.x += dist;
                    if (this.position.x > this.xmax) {
                        this.position.x = this.xmax;
                        this.animationStatus = 0
                    }
                    break
            }
        }

        console.log(verrou)

        animations.push(verrou);

        let poignee = object.getObjectByName("poignee");
        poignee.animationStatus = 0;
        poignee.amin = (-Math.PI) / 4;
        poignee.amax = 0;
        poignee.duration = 0.25;
        poignee.waitTime = 0.5;
        poignee.onClick = function (intersection) {
            console.log(this.animationStatus)

            if(!codeBon) return;

            switch (this.animationStatus) {
                case 0:
                    this.animationStatus = 1;
                    currentCode = "";
                    drawCanvas()
                    break;
            }
        }
        poignee.updateAnimation = function (dt) {
            let angle = dt * (this.amax - this.amin) / this.duration;

            switch (this.animationStatus) {
                case 1:
                    this.rotation.z -= angle;
                    if (this.rotation.z < this.amin) {
                        this.rotation.z = this.amin;
                        this.animationStatus = 2
                        this.t1 = this.waitTime;
                        //lance l'animation du verrou
                        verrou.animationStatus = 1;
                    }
                    break;
                case 2:
                    this.t1 -= dt;
                    if (this.t1 <= 0) {
                        this.animationStatus = 3;
                    }
                    break;
                case 3:
                    this.rotation.z += angle;
                    if (this.rotation.z > this.amax) {
                        this.rotation.z = this.amax;
                        this.animationStatus = 0
                    }
                    break
            }
        }
        animations.push(poignee)

        canvaMaterial = new THREE.CanvasTexture(canvaTexture);
        console.log(porte)
        porte.children[2].material[1].emissiveMap = canvaMaterial;
        porte.children[2].material[1].emissive = new THREE.Color(1.0, 1.0, 1.0);
        drawCanvas();
        //
        // let ul = document.querySelector("#objects");
        //
        // object.traverse(function (obj){
        //     // let li = document.createElement("li");
        //     // li.innerHTML = obj.name;
        //     // ul.appendChild(li);
        //
        //     obj.scale.set(0.5,0.5,0.5)
        // })


    }

    function onProgress(data) {
        if (data.lengthComputable) {
            var percentComplete = data.loaded / data.total * 100;
            document.getElementById('action').value = "Loading:" + percentComplete.toFixed(1) + '%';
        }
    };

    function onError(data) {
        console.error(data);
    };

    function drawCanvas(x, y) {
        if (textureEcran) {
            updateCode(x, y);

            canvaContext.drawImage(textureEcran, 0, 0, 256, 256);
            canvaContext.beginPath();
            canvaContext.font = "40px Arial Black";
            canvaContext.fillStyle = "white";
            canvaContext.fillText(currentCode, 32, 40)

            console.log(x * 256, y * 256)
            canvaContext.fillStyle = "red";
            canvaContext.arc(x * 256, (1 - y) * 256, 12, 0, 2 * Math.PI);
            canvaContext.fill()
        }

        canvaMaterial.needsUpdate = true;

    }

    function updateCode(x, y) {

        let caracCode = "";
        if (x * 256 > 12 && x * 256 < 237 && y * 256 > 6 && y * 256 < 206) {
            let xCode = Math.floor((x * 256 - 12) / 75) + 1;
            let yCode = Math.floor(((1 - y) * 256 - 6) / 50) - 1;
            if (yCode === 0 || yCode === 1 || yCode === 2) {


                caracCode = xCode + (yCode * 3);
            }

            if (yCode === 3) {

                switch (xCode) {
                    case 1 :
                        currentCode = currentCode.slice(0, currentCode.length-3);
                        break;
                    case 2 :
                        caracCode = "0";
                        break;
                    case 3 :
                        if(getNumberCarac(currentCode) >= 4) {
                            caracCode = "#";
                        }
                        break;
                }
            }
        }

        currentCode = currentCode + caracCode + " ";

        if(currentCode.slice(1, currentCode.length) === goodCode) {
            codeBon = true;

        } else {
            codeBon = false;

        }


    }

    function getNumberCarac(code) {
        let nReturn = 0;
        for(let codeC in code.split(" ")) {
            if(codeC !== "") {
                //si c'est un caractère
                nReturn++;
            }
        }
        return nReturn;
    }

    /******************************************************************************/
    /* PROGRAMME PRINCIPAL ********************************************************/
    start();
    animate();

</script>
</body>
</html>
